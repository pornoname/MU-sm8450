/** @file ConfigServiceGenerated.h

  Autogenerated configuration headers from mu_feature_config

  Copyright (c) Microsoft Corporation.
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#ifndef CONFIGSERVICEGENERATED_H
#define CONFIGSERVICEGENERATED_H
// The config public header must be included prior to this file
// Generated Header
//  Script: /home/robotix/UEFI_Porting/MU_Porting/ARM64/MU-Qcom/Features/CONFIG/SetupDataPkg/Tools/KnobService.py
//  Schema: /home/robotix/UEFI_Porting/MU_Porting/ARM64/MU-Qcom/Platforms/QcomPkg/CfgData/QcomCfgData.xml

STATIC CONST UINT16  CachedPolicySize = 0x141;
STATIC CHAR8 CachedPolicy[0x141];
STATIC BOOLEAN CachedPolicyInitialized = FALSE;
STATIC_ASSERT(0x141 <= MAX_UINT16, "Config too large!");

STATIC
EFI_STATUS
InitConfigPolicyCache (
  VOID
)
{
  POLICY_PPI *PolPpi  = NULL;
  EFI_STATUS Status;
  UINT16 ConfPolSize = CachedPolicySize;

  Status = PeiServicesLocatePpi (
            &gPeiPolicyPpiGuid,
            0,
            NULL,
            (VOID **)&PolPpi
            );

  if (EFI_ERROR (Status)) {
    DEBUG ((DEBUG_ERROR, "%a failed to locate policy service!\n", __FUNCTION__));
    ASSERT (FALSE);
    return Status;
  }

  Status = PolPpi->GetPolicy (PcdGetPtr (PcdConfigurationPolicyGuid), NULL, CachedPolicy, &ConfPolSize);
  if ((EFI_ERROR (Status)) || (ConfPolSize != CachedPolicySize)) {
    ASSERT (FALSE);
    return Status;
  }

  CachedPolicyInitialized = TRUE;

  return Status;
}

// Schema-defined knobs
// DummyStruct1 knob
// Get the current value of the DummyStruct1 knob
EFI_STATUS ConfigGetDummyStruct1 (
  SecondDummyStruct *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 54;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(SecondDummyStruct) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (SecondDummyStruct));
  return EFI_SUCCESS;
}

// DummyStruct2 knob
// Get the current value of the DummyStruct2 knob
EFI_STATUS ConfigGetDummyStruct2 (
  SecondDummyStruct *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 156;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(SecondDummyStruct) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (SecondDummyStruct));
  return EFI_SUCCESS;
}

// PowerOnPort0 knob
// Get the current value of the PowerOnPort0 knob
EFI_STATUS ConfigGetPowerOnPort0 (
  BOOLEAN *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 258;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(BOOLEAN) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (BOOLEAN));
  return EFI_SUCCESS;
}

// DummyKnob3 knob
// Get the current value of the DummyKnob3 knob
EFI_STATUS ConfigGetDummyKnob3 (
  ENUM_TYPE *Knob
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = 313;

  if (Knob == NULL) {
    return EFI_INVALID_PARAMETER;
  }

  if (!CachedPolicyInitialized) {
    Status = InitConfigPolicyCache ();
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(ENUM_TYPE) > CachedPolicySize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, CachedPolicy + Offset, sizeof (ENUM_TYPE));
  return EFI_SUCCESS;
}

#endif // CONFIGSERVICEGENERATED_H
